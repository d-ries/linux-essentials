# Logging

As you have probably noticed by now, your Linux installation is a complex system of different parts that work together. As a Linux sysadmin you can't monitor your system and all the services that run on it 24/7. This is why your system collects information for you as part of normal operation. This information is gathered into log-files. Your log-files contain a history of events that occured on your system. Most of those events are purely informative, signalling things that are expected when a computer system is running (a user signing in, a process starting, ...), while others try to alert the administrator that something out of the ordinary has occured (a user entering a wrong password, disk space running low, a process crashing, ...). As the amount of data logging generates can easily become intimidating it is important that you know how to filter this information, so that you can find the information and events that are of interest to you. If you know how to do this you'll be able to find notice when something might become a problem or, when things are going wrong. It gives you the skills to be able to understand what has happened and hopefully avoid the same problems in the future. As logs also contain a lot of security related information, using them is an important step in keeping your systems secure and safe from all kind of attacks.

Traditionally the log-files are a collection of textfiles written to the /var/log/-directory. Collecting the information from all the system components was the job of the rsyslog-daemon. While it is a fast and robust system, text files are not always the most user friendly way of presenting information. While there are some excellent tools to filter text based files, as you have seen in previous chapters, the simple structure of a line in a log make fine grained filtering difficult.  
Journald is a new service that takes care of logging, trying to work around the limitations of rsyslog. It stores the log data in a binary file, more like a database, which makes it possible to capture a lot more details about an event and allows for greater flexibility when filtering the data. It also preforms faster searching than plain text files. These logfiles are however, because of their binary format, not universily readable. Syslogd also makes it easier to send events to a networked computer, like a logging server.

Most Linux systems, including Ubuntu, choose a mix of both systems with journald capturing the events, and writing them to binary files, and then passing them on to rsyslogd to handle them in the traditional way. By making this combination, you are able to get the best of both worlds. 

## Journald

Journald is a daemon, a service, a process that runs in the background to collect logging events and process them. Like any daemon you can check it's current status by using `systemctl status systemd-journald`.
 
```bash
 student@linux-ess:~$ systemctl status systemd-journald
 ● systemd-journald.service - Journal Service
	Loaded: loaded (/lib/systemd/system/systemd-journald.service; static)
	Active: active (running) since Fri 2022-12-09 22:43:07 CET; 2min 49s ago
	TriggeredBy:● systemd-journald.socket
				● systemd-journald-audit.socket
             	● systemd-journald-dev-log.socket
	Docs: man:systemd-journald.service(8)
          man:journald.conf(5)
	Main PID: 237 (systemd-journal)
	Status: "Processing requests..."
	Tasks: 1 (limit: 4625)
	Memory: 14.1M
	CPU: 582ms
	CGroup: /system.slice/systemd-journald.service
	   └─237 /lib/systemd/systemd-journald

dec 09 22:43:07 linux-ess systemd-journald[237]: Journal started
dec 09 22:43:07 linux-ess systemd-journald[237]: Runtime Journal (/run/log/journal/4a9936ebf1354b5e968780179992fc86) is 4.9M, max 39.2M, 34.3M free.
dec 09 22:43:07 linux-ess systemd-journald[237]: Time spent on flushing to /var/log/journal/4a9936ebf1354b5e968780179992fc86 is 626616s for 565 entries.
dec 09 22:43:07 linux-ess systemd-journald[237]: System Journal (/var/log/journal/4a9936ebf1354b5e968780179992fc86) is 120.0M, max 2.1G, 2.0G free.
Notice: journal has been rotated since unit was started, output may be incomplete.
student@linux-ess:~$  
```
You can use this command to see the status of a running service: You can see it's active at the moment, with a status of "Processing requests". This means it is listening in the background, waiting for a process to send it something to add to the log. Underneath the information for the process, you see the last few log messages generated by this service. You'll always get these messages when examining a service with `systemctl`, it can be a quick way to check why a particular service is not working like it should.

Systemd is controlled by the `/etc/systemd/journald.conf` configuration file. When opening this file you'll notice that all the options are commented out (preceded by a #). This is because the default options are embedded in the executable file itself, and are not directly accessible. When you remove the # you'll override that particular default. The values that are filled in in the configuration file are the default values, so you only need to actually overwrite the ones you need to change. Examining all the options present in this file would be overkill for this course (and the advertised man-page does a very decent job if you need those), but the first one is an important one to be aware of.    
 
```bash
 cat /etc/systemd/journald.conf 

# This file is part of systemd.
# ...
# See journald.conf(5) for details.

[Journal]
#Storage=auto
#Compress=yes
#Seal=yes
...
```
Journald can keep its logfiles entirely in the `/run/log/journal` folder when this setting is set to `volatile`. You won't find this folder anywhere on your hard drive, it is a folder created when your system boots that is kept entirely in your computer's working memory. Like anything stored in RAM it is disposed of as the operating system shuts down. This means logfiles are only kept as long as your system is running. Every time your OS boots you start with a clean log. When this setting is set to `persistent` log files are kept in the `/var/log/journal` folder, a location that does exist on you hard disk drive. The journal is kept even when the system reboots. The `auto` setting which is Ubuntu's default means it will act in the persistent manner when the /var/log/journal folder exists, and act volatile when it doesn't. If you notice your system isn't keeping its log-files across boots, check if this folder exists and create it if necessary.

### Using the Journal

Using `systemctl status ...` you only get to see the last few lines a particular service generated. If you want to view the complete log, you need to use the `journalctl` command. This will open the complete journal in the `less` viewer. As this journal contains everything logged in the system starting from its first boot (or however long your system qis configured to keep old log events around) it quickly becomes too big to just go through it line by line. See it for yourself how many events there are by pressing the `End`-key to jump to the last line Journald strength comes from being able to filter the information so you only see the events you care about.

?> <i class="fa-solid fa-circle-info"></i> Because journalctl default behaviour is to open the journal with the less viewer, you can use the keys you learned in chapter 5 to navigate or search inside the journal.

The first `journalctl` option you should know, is `-e` or `--pager-end`. This will jump straight to the last page of the journal. As this is usually the part of the log you care about, you'll almost always use this option when using `journalctl`. Another practical option is `-x` or `--catalog`. This will add explanation to log lines when available. 

```bash
student@linux-ess:~$ journalctl -xe
dec 09 23:57:27 linux-ess systemd[1]: Stopped LSB: Start busybox udhcpd at boot time.
	Subject: A stop job for unit udhcpd.service has finished
	Defined-By: systemd
	Support: http://www.ubuntu.com/support
	A stop job for unit udhcpd.service has finished.
	The job identifier is 4877 and the job result is done.
dec 09 23:57:27 linux-ess sudo[4795]: pam_unix(sudo:session): session closed for user root

student@linux-ess:~$ journalctl -e
dec 09 23:57:27 linux-ess systemd[1]: Stopped LSB: Start busybox udhcpd at boot time.
dec 09 23:57:27 linux-ess sudo[4795]: pam_unix(sudo:session): session closed for user root
```
In the above example you see the same two events, with and without the -x option. It may not mean much now as the extra information isn't the most useful, but this option will save you once you start configuring things like Web Servers on your Linux machine. When you write you own configuration files it will tell you why a particular server will not start up with your configuration, pointing to things like invalid options or typos. You won't find this extra information in traditional text-based logs.

Another powerful option is `-u` or `--unit`. This allows you to only view the events generated by a particular 'unit', generally a service running on your system. 

```bash
student@linux-ess:~$ sudo journalctl -u cron.service -e -n 5 --no-pager
dec 09 23:17:01 linux-ess CRON[4117]: pam_unix(cron:session): session closed for user root
dec 09 23:30:01 linux-ess CRON[4218]: pam_unix(cron:session): session opened for user root(uid=0) by (uid=0)
dec 09 23:30:01 linux-ess CRON[4218]: pam_unix(cron:session): session closed for user root
dec 10 00:17:01 linux-ess CRON[5161]: pam_unix(cron:session): session opened for user root(uid=0) by (uid=0)
dec 10 00:17:01 linux-ess CRON[5161]: pam_unix(cron:session): session closed for user root
```
?> <i class="fa-solid fa-circle-info"></i> Tab-completion works with journalctl. Press Tab twice after -u to list the services you can filter by.

?> <i class="fa-solid fa-circle-info"></i> I use the options -n 5 (show the first 5 lines, just like head. Combine with option -r to make it work like tail) and --no-pager (do not open with less) to make these examples clearer.

Use `--dmesg` to see only the events generated by the kernel.

```bash
student@linux-ess:~$ journalctl --dmesg -n 2 -e --no-pager 
dec 10 00:00:03 linux-ess kernel: audit: type=1400 audit(1670626803.896:117): apparmor="DENIED" operation="capable" profile="/usr/sbin/cupsd" pid=4966 comm="cupsd" capability=12  capname="net_admin"
dec 10 00:00:03 linux-ess kernel: audit: type=1400 audit(1670626803.976:118): apparmor="DENIED" operation="capable" profile="/usr/sbin/cups-browsed" pid=4968 comm="cups-browsed" capability=23  capname="sys_nice"
```

As this log can go back months you'll also need to be able to specify a timeframe when filtering the journal. To only see the events generated since the last time you started your system, use the `-b` or `--boot` flag. To see the messages of a previous boot, provide an offset. -1 for the previous time your system started, -2 for the time before that, ...

You can ofcourse combine all options to further filter. The example below show the last 5 events the cron service generated, three boots ago. 

```bash
student@linux-ess:~$ journalctl -b -2 -u cron.service -e -n 5 --no-pager
nov 05 10:30:01 linux-ess CRON[4256]: pam_unix(cron:session): session closed for user root
nov 05 11:17:01 linux-ess CRON[4311]: pam_unix(cron:session): session opened for user root(uid=0) by (uid=0)
nov 05 11:17:01 linux-ess CRON[4311]: pam_unix(cron:session): session closed for user root
nov 05 11:30:01 linux-ess CRON[4321]: pam_unix(cron:session): session opened for user root(uid=0) by (uid=0)
nov 05 11:30:01 linux-ess CRON[4321]: pam_unix(cron:session): session closed for user root
``` 
?> <i class="fa-solid fa-circle-info"></i> `journalctl --list-boots` gives you an overview of when your system was booted with a timestamp, which is useful information by itself. It also includes to offsets you can use.

You can use `--since` and `--until` to specify a time range

```bash
student@linux-ess:~$ journalctl --since '5 min ago' -n 2 --no-pager
dec 10 00:48:12 linux-ess gnome-shell[1784]: Window manager warning: last_user_time (7508986) is greater than comparison timestamp 
dec 10 00:48:12 linux-ess gnome-shell[1784]: Window manager warning: W2 appears to be one of the offending windows with a timestamp

student@linux-ess:~$ journalctl --since '2022-12-09 23:00' -n 2 --no-pager
dec 09 23:02:09 linux-ess update-notifier[2468]: gtk_widget_get_scale_factor: assertion 'GTK_IS_WIDGET (widget)' failed
dec 09 23:02:09 linux-ess update-notifier[2468]: gtk_widget_get_scale_factor: assertion 'GTK_IS_WIDGET (widget)' failed

student@linux-ess:~$ journalctl --since 'yesterday' -n 2 --no-pager
dec 09 22:43:07 linux-ess kernel: Linux version 5.15.0-53-generic (buildd@lcy02-amd64-047) (gcc (Ubuntu 11.2.0-19ubuntu1) 11.2.0, GNU ld (GNU Binutils for Ubuntu) 2.38) 
dec 09 22:43:07 linux-ess kernel: Command line: BOOT_IMAGE=/boot/vmlinuz-5.15.0-53-generic root=UUID=069b1392-a138-4de1-9146-42f6c7cbbcf7 ro quiet splash

student@linux-ess:~$ journalctl --since '20 day ago' --until '5 day ago' -n 2 --no-pager #notice day not days, min not mins or minutes
nov 27 13:49:04 linux-ess kernel: Linux version 5.15.0-50-generic (buildd@lcy02-amd64-086) (gcc (Ubuntu 11.2.0-19ubuntu1) 11.2.0, GNU ld (GNU Binutils for Ubuntu) 2.38)
nov 27 13:49:04 linux-ess kernel: Command line: BOOT_IMAGE=/boot/vmlinuz-5.15.0-50-generic root=UUID=069b1392-a138-4de1-9146-42f6c7cbbcf7 ro quiet splash
```
?> <i class="fa-solid fa-circle-info"></i> Examples of valid timestamps are '2022-11-23 23:02:15', '2022-09-01', '12:00', now, today, yesterday, '5 hour ago' (min, hour, day, week, month, year), '-5 min'

### Priority levels

As you have probably noticed, not everything that is logged is necesarrily important or useful information. This is why every event that is logged also has a priority level. These are, from not important to very important:

Displayed in white in the journal:
- debug: The most verbose setting. Everything that a process can log is logged. This is only useful when debugging a specific problem as you will be able to follow every step a process takes. These messages are usually discarded. If you want to see debug events, you'll have to enable it in the journald configuration.
- info: Information part of normal operation.
- notice: Something unusual happened, but it is not an error. An example of this is a user that is allowed to, using sudo.

Displayed in yellow in the journal:
- warning: If no action is taken an error can be expected. You'll get a warning when your system is close to running out of storage space. Displayed in yellow.

Displayed in red in the journal:
- err: (short for error) A non-fatal error has occured. Meaning a service has encountered an error, but is still able to continue running.
- crit: (short for critical) A process has crashed, or a failure in a primary system component. 
- alert: A vital component stops working, expect data loss. Important security errors will also show up as crit. Action needs to be taken immediately.
- emerg: (short for emergency) Only used by the kernel. The system has become unusable. If possible this message will be communicated to all logged in users. As the logging-service is also likely to be affected, you wont see this priority in a log file.

Remember the ominous 'this incident will be reported' when trying to use sudo when you are not allowed to? 
```bash
jacob@linux-ess:/home/student$ sudo useradd jef
[sudo] password for jacob: 
jacob is not in the sudoers file.  This incident will be reported.

student@linux-ess:~$ journalctl -b -p alert --no-pager 
dec 10 01:54:59 linux-ess sudo[5753]:    jacob : user NOT in sudoers ; TTY=pts/0 ; PWD=/home/student ; USER=root ; COMMAND=/usr/sbin/useradd jef
```

You can filter by priority level using the `-p` option in combination with the levels mentioned above. You will see all the events with at least that priority. 

?> <i class="fa-solid fa-circle-info"></i> The options given here are just some of the more common options to filter the journal. See the manpage for `journalctl` to see the complete list.  
